<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>匈牙利算法</title>
      <link href="/2025/03/23/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/23/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[<a href="https://www.lanqiao.cn/problems/1326/learning/?page=6&first_category_id=1&second_category_id=8">question linked</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>; <span class="comment">// 增大数组容量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">250010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2, m;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">int</span> match[N]; <span class="comment">// 记录右边点匹配的左边点</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 访问标记</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 遍历右边的点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 右边点未匹配 或 原匹配点可找到新路径</span></span><br><span class="line">            <span class="keyword">if</span> (!match[j] || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 初始化邻接表头指针，很重要</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b); <span class="comment">// 将右边点编号映射到独立区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st); <span class="comment">// 每次重置访问标记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图最大匹配数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集与最小生成树</title>
      <link href="/2025/03/23/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2025/03/23/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lanqiao.cn/problems/1124/learning/?page=1&first_category_id=1&second_category_id=8">question linked </a></p><h3 id="kruskal-algorithm"><a href="#kruskal-algorithm" class="headerlink" title="kruskal algorithm"></a><em><strong>kruskal algorithm</strong></em></h3><p>时间复杂度:O(M * log(M));稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">3</span> * N, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b, w;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp; W ) &#123;</span><br><span class="line">      <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">  &#125;<span class="comment">//kruskal先找最小边排序;</span></span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//并查集找公共祖先，则为连通的，那么不能取;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">( <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//找到下一个没有用过的点;</span></span><br><span class="line">  <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(edges, edges + m);<span class="comment">//对m条边排序;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//初始化每个节点的父节点为自己; </span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">    a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);<span class="comment">//找祖先节点;</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      p[a] = b;<span class="comment">//合并,如果祖先节点不同;</span></span><br><span class="line">      res += w;<span class="comment">//添加一条路径</span></span><br><span class="line">      cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//n个点的图的最小生成树为n - 1条边;</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">    edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">kruskal</span>();</span><br><span class="line">  <span class="keyword">if</span> (result == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prim"><a href="#prim" class="headerlink" title="*** prim***"></a>*** prim***</h3><p>时间复杂度O(N ^ N + M);稠密图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>, M = <span class="number">3e4</span> + <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">   <span class="comment">//松弛操作有点类似dijkstra算法，但这是该点到最小生成树的最短距离，而dijkstra是到起点的最短距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);  <span class="comment">// 初始化邻接矩阵为INF</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; g[a][b]) &#123;</span><br><span class="line">            g[a][b] = c;</span><br><span class="line">            g[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">prim</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口与双指针</title>
      <link href="/2025/03/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2025/03/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>小明在维护一个程序员论坛时，收集了一份关于帖子“点赞”的日志，日志包含 N 行数据，每行记录了某个时刻 ts 和帖子编号 id 的点赞情况。他希望统计出哪些帖子曾被认为是“热帖”，定义为在任意长度为 D 的时间段内至少收到 K 个赞。任务是根据给定的日志统计所有曾是“热帖”的帖子编号，并按从小到大的顺序输出这些编号。</p><!-- inject --><h2 id="题目-日志统计-第九届蓝桥杯省赛C-B组"><a href="#题目-日志统计-第九届蓝桥杯省赛C-B组" class="headerlink" title="题目:日志统计(第九届蓝桥杯省赛C++ B组)"></a>题目:日志统计(第九届蓝桥杯省赛C++ B组)</h2><p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</p><p>其中每一行的格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts id  </span><br></pre></td></tr></table></figure><p>表示在 ts 时刻编号 id 的帖子收到一个”赞”。</p><p>现在小明想统计有哪些帖子曾经是”热帖”。</p><p>如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K个赞，小明就认为这个帖子曾是”热帖”。</p><p>具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。</p><p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 N,D,K。</p><p>以下 N 行每行一条日志，包含两个整数 ts 和 id。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按从小到大的顺序输出热帖 id。</p><p>每个 id 占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤N≤10^5,<br>0≤ts,id≤10^5,<br>1≤D≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 10 2</span><br><span class="line">0 1</span><br><span class="line">0 10</span><br><span class="line">10 10</span><br><span class="line">10 1</span><br><span class="line">9 1</span><br><span class="line">100 3</span><br><span class="line">100 3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;<span class="comment">//十万数量级</span></span><br><span class="line">PII logs[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d, k;</span><br><span class="line"><span class="type">int</span> cnt[N];<span class="comment">//热帖</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;logs[i].x, &amp;logs[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(logs, logs + n);<span class="comment">//按时间排序;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> id = logs[i].y;</span><br><span class="line">        cnt[id] ++;</span><br><span class="line">    <span class="keyword">while</span> (logs[i].x - logs[j].x &gt;= d) &#123;<span class="comment">//维护一个滑动窗口</span></span><br><span class="line">        cnt[logs[j].y]--;  <span class="comment">// 移出窗口的帖子计数减1,有可能有多个点赞，所以加循环</span></span><br><span class="line">        j++;               <span class="comment">// 左指针右移</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[id] &gt;= k) st[id] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100010</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st[i])  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目：未来竞赛-蓝桥杯16届模拟赛"><a href="#题目：未来竞赛-蓝桥杯16届模拟赛" class="headerlink" title="题目：未来竞赛(蓝桥杯16届模拟赛)"></a>题目：未来竞赛(蓝桥杯16届模拟赛)</h2><p>[<a href="https://www.lanqiao.cn/problems/20273/learning/?contest_id=250">5.未来竞赛(滑动窗口 and 二分)【算法赛】 - 蓝桥云课</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N, D;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个国家的参赛者</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; countryToComputers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        countryToComputers[A[i]].<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">// 电脑编号从1开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> total = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [country, computers] : countryToComputers) &#123;</span><br><span class="line">        <span class="type">int</span> m = computers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算每个国家的合法监控方式</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ways = <span class="number">1</span> + m; <span class="comment">// 选择0台或1台电脑的方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用滑动窗口计算选择2台电脑的方式</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">1</span>; right &lt; m; ++right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (computers[right] - computers[left] &gt; D) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从left到right-1的电脑都可以与right配对</span></span><br><span class="line">            ways += (right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        total = (total * ways) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减去全不选的情况</span></span><br><span class="line">    total = (total - <span class="number">1</span> + MOD) % MOD;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dijkstra</title>
      <link href="/2025/03/22/dijkstra/"/>
      <url>/2025/03/22/dijkstra/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>SPFA（Shortest Path Faster Algorithm）是一种针对最短路径问题的高效算法，特别适用于处理含有负权边的图。其核心思想是通过动态选择可能优化路径的节点进行松弛，避免冗余操作。与Dijkstra算法相比，SPFA允许节点多次入队和处理，从而能及时更新路径长度，尤其在遇到负权边时表现出更好的灵活性。然而，如果图中存在负权环，SPFA可能会出现死循环，因此需要额外判断。整体而言，SPFA通过“按需松弛”提高了效率，适应性强，但在使用时需关注负权环的问题。</p><!-- inject --><p>题目链接[<a href="https://www.lanqiao.cn/problems/1121/learning/?page=1&first_category_id=1&second_category_id=8">1.蓝桥公园 - 单源最短路径</a>]</p><h3 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a><em><strong>floyd</strong></em></h3><p><em><strong>时间复杂度O(n ^ n  ^ n)  n &#x3D;&#x3D; 100左右</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=n; j++ ) &#123;</span><br><span class="line">          <span class="keyword">if</span> (g[i][j] &gt; g[i][k] + g[k][j])</span><br><span class="line">            g[i][j] = g[i][k] + g[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(g, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) g[i][i] = <span class="number">0</span>;<span class="comment">//处理自环；i -&gt; k -&gt; j时k == i的情况;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> ( m -- ) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (c &lt; g[a][b]) &#123;</span><br><span class="line">      g[a][b] = c;</span><br><span class="line">      g[b][a] = c;<span class="comment">//最小权边;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">floyd</span>();</span><br><span class="line">  <span class="keyword">while</span> (q -- ) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="keyword">if</span> (g[u][v] == INF) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="comment">// 不可达</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g[u][v]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a><em><strong>dijkstra</strong></em></h3><p><em><strong>间复杂度O(n ^ n × log(m)),n为点，m为边数</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵存储图</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 标记是否已确定最短路</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 距离数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法：计算从u到v的最短路径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[u] = <span class="number">0</span>; <span class="comment">// 起点距离初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n-1次，确定每个节点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 当前未确定最短路的最小距离节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 无可达节点，提前退出</span></span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">// 标记为已确定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新所有节点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + g[t][j]) &#123;</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[v] == INF ? <span class="number">-1</span> : dist[v]; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化邻接矩阵为无穷大，自环为0</span></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取边并更新邻接矩阵（假设为无向图）</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; g[a][b]) &#123; <span class="comment">// 处理重边，保留最小权重</span></span><br><span class="line">            g[a][b] = c;</span><br><span class="line">            g[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理多组查询</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>(u, v)); <span class="comment">// 调用Dijkstra</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化版dijkstra-priority-queue"><a href="#优化版dijkstra-priority-queue" class="headerlink" title="优化版dijkstra(priority_queue)"></a>优化版dijkstra(priority_queue)</h3><p><em><strong>堆化优化后为：O(m × log(n)）</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> <span class="number">+10</span>, M = <span class="number">1e6</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx, w[M];<span class="comment">//链式前向星;</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//从1开始;</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">//first表示单源最短距离，second表示当前节点</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">      <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;<span class="comment">//当前点已经添加过;</span></span><br><span class="line">      st[ver] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) &#123;</span><br><span class="line">          <span class="type">int</span> j = e[i];</span><br><span class="line">          <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">              dist[j] = distance + w[i];</span><br><span class="line">              pq.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return dist[n] == INF ? -1 : dist[n];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="comment">// 单向边处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dist[i] == INF ? <span class="number">-1</span> : dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理负权边-spfa"><a href="#处理负权边-spfa" class="headerlink" title="处理负权边-spfa"></a>处理负权边-spfa</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPFA（Shortest Path Faster Algorithm）的核心思想是<strong>动态选择可能优化最短路径的节点进行松弛</strong>，避免全局遍历所有边的冗余操作。其核心机制与Dijkstra的贪心策略不同，具体思想可通过以下步骤拆解：</p><hr><h3 id="SPFA的核心思想"><a href="#SPFA的核心思想" class="headerlink" title="SPFA的核心思想"></a><strong>SPFA的核心思想</strong></h3><ol><li><p><strong>松弛驱动的动态更新</strong></p><ul><li>只处理<strong>可能缩短路径的节点</strong>。当一个节点被松弛成功（即发现更短的路径）时，才将其加入队列等待后续处理。</li><li>与Dijkstra的“一次性确定最短路径”不同，SPFA允许节点<strong>多次入队</strong>，确保所有可能的路径优化都被探索。</li></ul></li><li><p><strong>队列维护待处理节点</strong></p><ul><li>使用普通队列（而非优先队列）管理待处理的节点，遵循先进先出原则。</li><li>节点出队时，尝试松弛其邻接边；若邻接点距离被更新且不在队列中，则将其入队。</li></ul></li><li><p><strong>处理负权边的能力</strong></p><ul><li>由于允许节点多次松弛，即使存在负权边导致路径反复缩短，SPFA仍能正确更新距离。</li><li>但图中若存在<strong>负权环</strong>，SPFA会陷入死循环（需额外判断环的存在）。</li></ul></li></ol><hr><h3 id="与Dijkstra算法的对比"><a href="#与Dijkstra算法的对比" class="headerlink" title="与Dijkstra算法的对比"></a><strong>与Dijkstra算法的对比</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Dijkstra</strong></th><th><strong>SPFA</strong></th></tr></thead><tbody><tr><td><strong>策略</strong></td><td>贪心选择当前距离最小的节点</td><td>动态处理可能被松弛的节点</td></tr><tr><td><strong>数据结构</strong></td><td>优先队列（最小堆）</td><td>普通队列</td></tr><tr><td><strong>节点处理次数</strong></td><td>每个节点仅处理一次</td><td>节点可能多次入队</td></tr><tr><td><strong>负权边支持</strong></td><td>❌ 无法处理</td><td>✅ 支持（无负权环时）</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(m log n)（堆优化）</td><td>平均O(m)，最坏O(nm)</td></tr><tr><td><strong>适用场景</strong></td><td>边权非负的图</td><td>含负权边但无负权环的图</td></tr></tbody></table><hr><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a><strong>举例说明</strong></h3><p>假设节点<strong>A</strong>的最短距离初始为5，后续发现一条通过负权边的路径使其距离变为3：</p><ul><li><strong>Dijkstra</strong>：已处理过A，不再更新，导致错误。</li><li><strong>SPFA</strong>：将A重新入队，继续松弛其邻接边，最终得到正确的最短距离。</li></ul><hr><h3 id="SPFA的关键优势"><a href="#SPFA的关键优势" class="headerlink" title="SPFA的关键优势"></a><strong>SPFA的关键优势</strong></h3><ul><li><strong>高效性</strong>：通过队列减少冗余松弛，实际运行效率接近BFS。</li><li><strong>灵活性</strong>：支持负权边，弥补了Dijkstra的不足。</li><li><strong>动态性</strong>：每次只处理可能影响后续路径的节点，避免全局遍历。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>SPFA的思想是<strong>“按需松弛”</strong>，通过队列动态管理需要更新的节点，确保每次操作都是必要的。与Dijkstra的“贪心固化路径”不同，SPFA的灵活性使其能处理更复杂的图结构（如含负权边），但需注意负权环的检测。两者本质区别在于<strong>是否允许节点重复参与路径优化</strong>，这决定了它们在不同场景下的适用性。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单源最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高次幂与费马小引理</title>
      <link href="/2025/03/20/%E9%AB%98%E6%AC%A1%E5%B9%82%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%BC%95%E7%90%86/"/>
      <url>/2025/03/20/%E9%AB%98%E6%AC%A1%E5%B9%82%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>在这个问题中，魔术师小蓝通过对三个红包中的金币数量进行 N 次变换来展示一个红包魔术。每次变换会将每个红包的金币数更改为其他两个红包金币数的乘积。给定初始的 A、B、C 和变换次数 N，目标是计算 N 次变换后这三个红包金币数量的总乘积，并对 1e9+7 取模以避免结果过大。题目涉及使用费马小定理来简化计算过程，以提高效率。输入包括多个测试用例，每个用例提供初始金币数和变换次数。</p><!-- inject --><p><em><strong>题目链接[<a href="https://www.lanqiao.cn/problems/20239/learning/?contest_id=240">6.春晚魔术【算法赛】 - 蓝桥云课</a>]</strong></em></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在蓝桥卫视春晚的直播现场，魔术师小蓝表演了一个红包魔术。只见他拿出了三个红包，里边分别装有 A、B 和 C 个金币。而后，他挥动魔术棒，念动咒语“福禄寿喜财神到～”，对红包里的金币进行 <em>N</em> 次变换。每次变换，每个红包的金币数量都会变成其他两个红包金币数量的乘积。</p><p>例如：</p><ul><li>初始金币数量 A&#x3D;2, B&#x3D;3，C&#x3D;5，进行 N*&#x3D;1 次变换后，金币数量变为 15，10，6。</li><li>初始金币数量 A&#x3D;1，B&#x3D;2，C&#x3D;3，进行 N&#x3D;2次变换后，金币数量变为 6，12，18。</li></ul><p>变换结束后，小蓝得意地问观众：“现在，你们知道三个红包里金币的总乘积是多少吗？” 他飞快地心算了一下，并报出一个数字：“让我来揭晓答案吧！总乘积是…嗯…（不知道算没算对，只知道算得快）”。</p><p>作为观众，请你计算 <em>N</em> 次变换后，三个红包金币数量的总乘积。由于结果可能很大，请输出其对 1e9+7取模的结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 T (1≤<em>T</em>≤103)，表示测试用例的数量。</p><p>接下来的 T* 行，每行包含四个整数 A<em>，</em>B<em>，</em>C* 和 N*（1≤A,B,C,N≤1e9），表示一组数据。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，输出一个整数，表示 N* 次变换后三个红包金币数量的总乘积。由于结果可能很大，请输出其对 1e9+7 取模的结果。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2 3 5 1</span><br><span class="line">1 2 3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">900</span><br><span class="line">1296</span><br></pre></td></tr></table></figure><p>前置知识:</p><p>问题涉及利用费马小定理对指数进行降级的数学原理。以下是详细解释：</p><hr><h3 id="核心数学原理"><a href="#核心数学原理" class="headerlink" title="核心数学原理"></a><strong>核心数学原理</strong></h3><p>当模数 <em>p</em> 是质数时，根据<strong>费马小定理</strong> ，对任意整数 <em>a</em> 不被 <em>p</em> 整除，有：</p><p><em>a**p</em>−1≡1(mod<em>p</em>)</p><p>因此，对于任意指数 <em>b</em>，可以将其简化为 <em>b</em>mod(<em>p</em>−1)，即：</p><p><em>a**b</em>≡<em>a**b</em>mod(<em>p</em>−1)(mod<em>p</em>)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int unsigned long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k, <span class="type">int</span> MOD)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * x %MOD;</span><br><span class="line">    x = x * x % MOD;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">      <span class="type">int</span> a, b, c, n;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; n;</span><br><span class="line">      <span class="type">int</span> k = <span class="built_in">qmi</span>(<span class="number">2</span>, n, MOD - <span class="number">1</span>);<span class="comment">//费马小引理;</span></span><br><span class="line">      <span class="type">int</span> x = a % MOD;</span><br><span class="line">        x = (x * (b % MOD)) % MOD;</span><br><span class="line">        x = (x * (c % MOD)) % MOD;</span><br><span class="line">      <span class="type">int</span> res = <span class="built_in">qmi</span>(x, k, MOD) % MOD;</span><br><span class="line">      cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性筛质因数</title>
      <link href="/2025/03/18/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
      <url>/2025/03/18/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>题目要求计算正整数 N 的每个数的最小质因子的总和，即求和 $\sum\limits_{i&#x3D;2}^N F(i)$。输入中包含多个测试数据，数量 T 可达 10^6，而 N 的范围为 2 到 2×10^7。为了高效解决问题，可以采用线性筛法（或欧拉筛），其相较于传统的试除法具有更好的性能表现，能够在较短时间内完成质因子的计算并输出结果。</p><!-- inject --><p><em><strong>题目链接[<a href="https://www.lanqiao.cn/problems/1140/learning/?page=1&first_category_id=1&second_category_id=8">15.最小质因子之和(Hard Version) - 蓝桥云课</a>]</strong></em></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义 F(i) 表示整数 <em>i</em> 的最小质因子。现给定一个正整数 <em>N</em>，请你求出 $\sum\limits_{i&#x3D;2}^N F(i)$</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第 11 行为一个整数 <em>T</em>，表示测试数据数量。</p><p>接下来的 <em>T</em> 行每行包含一个正整数* N*。</p><p>$1≤T≤10^6，2≤N≤2×10^7。$</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出共 <em>T</em> 行，每行包含一个整数，表示答案。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><blockquote><p>输入</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">28</span><br><span class="line">59</span><br></pre></td></tr></table></figure><h2 id="普通素数的求法-试除法"><a href="#普通素数的求法-试除法" class="headerlink" title="普通素数的求法(试除法)"></a>普通素数的求法(试除法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_n = <span class="number">2e7</span>;</span><br><span class="line"><span class="type">int</span> minp[max_n + <span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[max_n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">precompute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_n; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> is_prime = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(i); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                minp[i] = j; <span class="comment">//合数的质因数为j</span></span><br><span class="line">                is_prime = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//保证找到最小质因数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_prime) minp[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理（实际会超时）</span></span><br><span class="line">    <span class="built_in">precompute</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_n; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + minp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理查询</span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        cout &lt;&lt; sum[N] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线性筛质数（欧拉筛）"><a href="#线性筛质数（欧拉筛）" class="headerlink" title="线性筛质数（欧拉筛）"></a>线性筛质数（欧拉筛）</h2><p>前置知识：[<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/10920095">算术基本定理_百度百科</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_n = <span class="number">2e7</span>;</span><br><span class="line"><span class="type">int</span> minp[max_n + <span class="number">1</span>];      <span class="comment">// 最小质因子表</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[min_n + <span class="number">1</span>]; <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="type">bool</span> st[max_n + <span class="number">1</span>];       <span class="comment">// 筛标记</span></span><br><span class="line"><span class="type">int</span> primes[max_n];        <span class="comment">// 质数表</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛法预处理最小质因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_minp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123; <span class="comment">// i 是质数</span></span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            minp[i] = i; <span class="comment">// 质数的最小质因子是自身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用 i 的最小质因子筛掉合数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; primes[j] * i &lt;= max_n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;<span class="comment">//算数基本定理，一个合数可以被分解为多个质数的乘积;</span></span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            minp[t] = primes[j]; <span class="comment">// 合数 t 的最小质因子是 primes[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 避免重复筛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理最小质因子和前缀和</span></span><br><span class="line">    <span class="built_in">get_minp</span>();</span><br><span class="line">    sum[<span class="number">0</span>] = sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + minp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输入输出</span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        cout &lt;&lt; sum[N] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比：线性筛法的优势"><a href="#对比：线性筛法的优势" class="headerlink" title="对比：线性筛法的优势"></a><strong>对比：线性筛法的优势</strong></h3><table><thead><tr><th>方法</th><th>预处理时间</th><th>查询时间</th><th>适用规模</th></tr></thead><tbody><tr><td>试除法</td><td><em>O</em>(<em>N</em> *sqrt( <em>N</em>))</td><td><em>O</em>(1)</td><td><em>N</em>  ≤ 10^4</td></tr><tr><td>线性筛法</td><td><em>O</em>(<em>N</em>)</td><td><em>O</em>(1)</td><td><em>N</em>  ≤  2×10^7</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kmp算法</title>
      <link href="/2025/03/15/kmp%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/15/kmp%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>本文讨论了字符串匹配的两种解法：暴力枚举和KMP算法。暴力枚举方法通过双层循环检查每个字符是否匹配，时间复杂度为O(N*M)。而KMP算法则通过构造next数组来优化匹配过程，避免重复比较，从而实现线性时间复杂度O(N+M)。其中，next数组帮助确定在不匹配时回溯的位置，提高了匹配效率。</p><!-- inject --><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><code>str = abcabca </code></p><p><code>ptr = abc</code></p><p>那么称 <code>ptr</code> 在 <code>str</code> 字符串中匹配,且第一次匹配位置为 0，第二次为 3；</p><h3 id="解法一-暴力枚举"><a href="#解法一-暴力枚举" class="headerlink" title="解法一 暴力枚举;"></a>解法一 暴力枚举;</h3><p>传统代码处理字符串匹配问题时会进行两次循环，第一层为选定 <code>str </code>字符串中的字符, 第二层为 开始比较 <code>ptr </code>与次字符是否相等</p><ul><li>如若相等，则比较 <code>str </code>与 <code>ptr</code>的下一字符，</li><li>如若不等，则第一层循环加一，从<code>str </code>下一个字符开始比较</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Match</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> n, <span class="type">char</span>* ptr, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i + j] != ptr[j]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (j == m) ans.<span class="built_in">push_back</span>(i);<span class="comment">//当前位置加入答案数组;</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**时间复杂度: $O(N *M) $ **</p><h3 id="解法二-kmp算法；"><a href="#解法二-kmp算法；" class="headerlink" title="解法二 kmp算法；"></a>解法二 kmp算法；</h3><p>而kmp算法的核心是：如若不匹配，则从k &#x3D; next[k]这个位置开始重新匹配，省去从0开始的中间重复的操作，从而将时间复杂度转换为线性;</p><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul><li><strong>next数组</strong>：<code>next[q]</code>表示模式串<code>str[0..q]</code>的最长公共前后缀的长度。</li><li><strong>回溯逻辑</strong>：当字符不匹配时，通过<code>k = next[k]</code>回溯，利用已计算的信息避免重复匹配。</li><li><strong>时间复杂度</strong>：<code>O(plen)</code>，每个字符最多被匹配两次（前进和回溯）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//模式串操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal_next</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> *next, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;<span class="comment">//最长公共前后缀长度;</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//第一个字符为0；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="number">1</span>; q &lt;= len - <span class="number">1</span>; q++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; str[k + <span class="number">1</span>] != str[q]) &#123;</span><br><span class="line">            k = next[k];<span class="comment">//从最长公共前后缀长度开始;也可以从k--开始，只不过这样更高效;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[k + <span class="number">1</span>] == str[q]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[q] = k;<span class="comment">//保存最长公共前后缀长度再next数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> slen, <span class="type">char</span>* ptr, <span class="type">int</span> plen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;<span class="comment">//已匹配字符串数量</span></span><br><span class="line">    <span class="type">int</span> *next = <span class="keyword">new</span> <span class="type">int</span>[plen];</span><br><span class="line">    <span class="built_in">cal_next</span>(ptr, next, plen);</span><br><span class="line">    <span class="comment">//遍历主串的每个字符;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; slen; i++) &#123;</span><br><span class="line">        <span class="comment">// 当不匹配且k&gt;-1时，回溯k到前一个位置的next值</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; ptr[k + <span class="number">1</span>] != str[i]) &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">            <span class="comment">// 利用next数组跳过已匹配部分</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr[k + <span class="number">1</span>] == str[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k指向模式串末尾，说明完全匹配</span></span><br><span class="line">        <span class="keyword">if</span> (k == plen - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回模式串在主串中的起始位置</span></span><br><span class="line">            <span class="keyword">return</span> i - plen + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>], ptr[<span class="number">20</span>];</span><br><span class="line">    cin &gt;&gt; str &gt;&gt; ptr;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">kmp</span>(str, <span class="number">10</span>, ptr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**时间复杂度: $O(N + M) $ **</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flood-fill算法</title>
      <link href="/2025/03/08/flood-fill%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/08/flood-fill%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>该问题要求编写程序计算你从指定的黑色瓷砖出发能够到达的所有黑色瓷砖数量。输入数据包括多个数据集合，每个集合包含瓷砖的宽度和高度，以及瓷砖的颜色信息。黑色瓷砖用‘.’表示，红色瓷砖用‘#’表示，而起始位置用‘@’表示。程序需要遍历相邻的黑色瓷砖，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）算法来实现。输出每个数据集合中可到达的黑色瓷砖数，包括起始位置。结束输入时，当读取到“0 0”时停止处理。数据范围为1≤W,H≤20。</p><!-- inject --><p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p><p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p><p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包括多个数据集合。</p><p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p><p>在接下来的 H 行中，每行包括 W个字符。每个字符表示一块瓷砖的颜色，规则如下</p><p>1）‘.’：黑色的瓷砖；<br>2）‘#’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p><p>当在一行中读入的是两个零时，表示输入结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤W,H≤20</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">6 9 </span><br><span class="line">....#. </span><br><span class="line">.....# </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">#@...# </span><br><span class="line">.#..#. </span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure><h3 id="解法一bfs"><a href="#解法一bfs" class="headerlink" title="解法一bfs"></a>解法一bfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> dx[] &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy&#125;);<span class="comment">//压入第一个元素;</span></span><br><span class="line">    g[sx][sy] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">   <span class="keyword">while</span> (! q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">       PII t = q.<span class="built_in">front</span>();<span class="comment">//取队列元素</span></span><br><span class="line">       res++;</span><br><span class="line">       q.<span class="built_in">pop</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = dx[i] + t.x;</span><br><span class="line">        <span class="type">int</span> y = dy[i] + t.y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || g[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, m || n) &#123;<span class="comment">//注意先输入行数;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; g[i];</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                     x = i;</span><br><span class="line">                     y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二dfs"><a href="#解法二dfs" class="headerlink" title="解法二dfs"></a>解法二dfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dx[] &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;<span class="comment">//表示当前格子可以搜索;</span></span><br><span class="line">    g[sx][sy] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = sx + dx[i];</span><br><span class="line">        <span class="type">int</span> y = sy + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; n &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt;m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; g[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            res += <span class="built_in">dfs</span>(x, y);<span class="comment">//加可以搜索的格子数;</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, m || n) &#123;<span class="comment">//注意先输入行数;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; g[i];</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                     x = i;</span><br><span class="line">                     y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组与线段树</title>
      <link href="/2025/03/04/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2025/03/04/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>题目一涉及操作一个数列，允许对元素进行修改和求子数列的和。输入包括数列的长度和操作次数，数列本身，以及每个操作的具体细节。题目要求在操作类型为求和时输出对应的结果。题目二则关注星星的坐标，定义了星星的等级为其左下方（包括正左和正下）星星的数量。输入给出星星的数量和各自的坐标，要求统计每个等级的星星数量，并按级别输出结果。这两个题目的数据范围较大，需要有效的算法处理。</p><!-- inject --><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>给定 n个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b][a,b] 的连续和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。</p><p>第二行包含 n 个整数，表示完整数列。</p><p>接下来 m 行，每行包含三个整数 k,a,b （k&#x3D;0，表示求子数列[a,b][a,b]的和；k&#x3D;1，表示第 a个数加 b）。</p><p>数列从 11 开始计数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出若干行数字，表示 k&#x3D;0 时，对应的子数列 [a,b][a,b] 的连续和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤m≤100000<br>1≤a≤b≤n<br>数据保证在任何时候，数列中所有元素之和均在 int 范围内。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">1 1 5</span><br><span class="line">0 1 3</span><br><span class="line">0 4 8</span><br><span class="line">1 7 5</span><br><span class="line">0 4 8</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">30</span><br><span class="line">35</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; ( -x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); <span class="comment">//读取a[i]数组;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">add</span>(i, a[i]);<span class="comment">//第i个位置加上某个数;tr[n]树状数组初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(x, y); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树解法"><a href="#线段树解法" class="headerlink" title="线段树解法"></a>线段树解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r]&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//求父节点;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;<span class="comment">//查询区间在节点区间内，直接返回;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);<span class="comment">//查询节点区间左边与查询区间交集;左子树</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].sum += v;<span class="comment">//叶子节点加一构建后求父节点;</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);<span class="comment">//左子树;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a, b, k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, a, b));<span class="comment">//查询区间a到b</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, a, b);<span class="comment">//修改a点 + b</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。</p><p>本题采用数学上的平面直角坐标系，即 xx 轴向右为正方向，y 轴向上为正方向。</p><p>如果一个星星的左下方（包含正左和正下）有 k 颗星星，就说这颗星星是 k 级的。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/12/11/19_6f40991a1c-1.png" alt="1.png"></p><p>例如，上图中星星 55 是 33 级的（1,2,4 在它左下），星星 2,4是 1 级的。</p><p>例图中有 1 个 0 级，2 个 1 级，1 个 2 级，1 个 3 级的星星。</p><p>给定星星的位置，输出各级星星的数目。</p><p>换句话说，给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 N，表示星星的数目；</p><p>接下来 N行给出每颗星星的坐标，坐标用两个整数 x,y表示；</p><p>不会有星星重叠。星星按 y 坐标增序给出，y 坐标相同的按 x 坐标增序给出。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>N行，每行一个整数，分别是 0 级，1 级，2级，……，N−1 级的星星的数目。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤15000<br>0≤x,y≤320000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">5 1</span><br><span class="line">7 1</span><br><span class="line">3 3</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32010</span>;</span><br><span class="line"><span class="type">int</span> tr[N], level[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; N; i += <span class="built_in">lowbit</span>(i)) tr[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span> <span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        x++;</span><br><span class="line">        level[<span class="built_in">sum</span>(x)]++;<span class="comment">//第几层星星增加;sum里面没有当前星星;</span></span><br><span class="line">        <span class="built_in">add</span>(x);<span class="comment">//再加x这个坐标后，星星总数;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; level[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单枚举与模拟</title>
      <link href="/2025/03/01/%E7%AE%80%E5%8D%95%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E6%8B%9F/"/>
      <url>/2025/03/01/%E7%AE%80%E5%8D%95%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>小明在处理历史文献中的日期时遇到格式不统一的问题，这些日期在1960年到2059年之间，并且省略了年份的前两位，导致每个日期可能对应多个实际日期。文章要求根据给定的日期格式”AA&#x2F;BB&#x2F;CC”输出所有可能的真实日期，并按照时间排序。此外，牛牛对回文日期感兴趣，希望在指定日期范围内计算出多少个日期的88位数字表示是回文的。同时，提到了如何找出某单位票据ID中出现的断号和重号，及如何统计满足条件的三元组数量，最后涉及连号区间的计算方法。这些问题涵盖了日期处理、数据结构与算法的多种应用。</p><!-- inject --><h1 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h1><p>日期八位字符的处理与校验；</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。</p><p>小明知道这些日期都在1960年1月1日至2059年12月31日。</p><p>令小明头疼的是，这些日期采用的格式非常不统一，有采用年&#x2F;月&#x2F;日的，有采用月&#x2F;日&#x2F;年的，还有采用日&#x2F;月&#x2F;年的。</p><p>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p><p>比如02&#x2F;03&#x2F;04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p><p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个日期，格式是”AA&#x2F;BB&#x2F;CC”。</p><p>即每个’&#x2F;’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。</p><p>多个日期按从早到晚排列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤A,B,C≤90≤A,B,C≤9</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02/03/04</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2002-03-04</span><br><span class="line">2004-02-03</span><br><span class="line">2004-03-02</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span><span class="comment">//格式化输入输出,sacnf,printf;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> days[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_valid</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(month == <span class="number">0</span> || month &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(day == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(month != <span class="number">2</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(day &gt; days[month]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">bool</span> leap = year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> || year % <span class="number">400</span> == <span class="number">0</span>;<span class="comment">//判断为闰年;</span></span><br><span class="line">        <span class="keyword">if</span>(day &gt; <span class="number">28</span> + leap) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> date = <span class="number">19600101</span>; date &lt; <span class="number">20591231</span>; date++)&#123;</span><br><span class="line">        <span class="type">int</span> year = date / <span class="number">10000</span>, month = date % <span class="number">10000</span> / <span class="number">100</span>, day = date % <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check_valid</span>(year, month, day))&#123;</span><br><span class="line">            <span class="keyword">if</span>(year % <span class="number">100</span> == a &amp;&amp; month == b &amp;&amp; day == c || <span class="comment">//年/月/日</span></span><br><span class="line">                month == a &amp;&amp; day == b &amp;&amp; year % <span class="number">100</span> == c || <span class="comment">//月/日/年</span></span><br><span class="line">                day == a &amp;&amp; month == b &amp;&amp; year % <span class="number">100</span> == c)&#123;    <span class="comment">//日/月/年</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>,year, month, day);</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目-回文日期"><a href="#题目-回文日期" class="headerlink" title="题目-回文日期"></a>题目-回文日期</h2><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p><p>牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。</p><p>显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。</p><p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8位数字是回文的。</p><p>现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。</p><p>一个 8 位数字是回文的，当且仅当对于所有的 ii(1≤i≤8) 从左向右数的第 i 个数字和第 9−i个数字（即从右向左数的第 i 个数字）是相同的。</p><p>例如：</p><ul><li>对于 2016年 11 月 19 日，用 88 位数字 20161119 表示，它不是回文的。</li><li>对于 2010年 11 月 22 日，用 88 位数字 20100102 表示，它是回文的。</li><li>对于 2010 年 10 月 22 日，用 88 位数字 20101002 表示，它不是回文的。</li></ul><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包括两行，每行包括一个 8 位数字。</p><p>第一行表示牛牛指定的起始日期 date1，第二行表示牛牛指定的终止日期 date2。保证 date1 和 date2 都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。</p><p>保证 date1 一定不晚于 date2。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含一个整数，表示在 date1date1 和 date2date2 之间，有多少个日期是回文的。</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20110101</span><br><span class="line">20111231</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//枚举year，先求对应位，再求出对应的回文数，如果满足日期条件，那么可以判断日期为回文数;</span></span><br><span class="line"><span class="type">int</span> months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_valid</span><span class="params">(<span class="type">int</span> date)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> year = date / <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> month = date % <span class="number">10000</span> / <span class="number">100</span>;<span class="comment">//先得到四位，再求前两位;</span></span><br><span class="line">    <span class="type">int</span> day = date % <span class="number">100</span>; <span class="comment">//得到后两位;</span></span><br><span class="line">    <span class="keyword">if</span>(month &gt;= <span class="number">13</span> || !month || !day) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( month != <span class="number">2</span> &amp;&amp; day &gt; months[month]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(month == <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="type">bool</span> leap =( year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);<span class="comment">//是闰年;</span></span><br><span class="line">        <span class="keyword">if</span>( day &gt; <span class="number">28</span> + leap) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是闰年就加leap，否则不加;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> date1, date2;</span><br><span class="line">    cin &gt;&gt; date1 &gt;&gt; date2;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> date = i,x = i;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            date = date * <span class="number">10</span> + x %<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check_valid</span>(date) &amp;&amp; date1 &lt;= date &amp;&amp; date &lt;= date2) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>特别地:回文数求法与将数字转换为字符数组</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="keyword">while</span>(num)&#123;</span><br><span class="line">    res = res * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">&#125;<span class="comment">//将数字123转换为回文数321;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>], i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">while</span>(num)&#123;</span><br><span class="line">a[i] =  num % <span class="number">10</span>;</span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序模拟"><a href="#排序模拟" class="headerlink" title="排序模拟"></a>排序模拟</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><strong>sstream库处理数据读入问题</strong></p><p>某涉密单位下发了某种票据，并要在年终全部收回。</p><p>每张票据有唯一的ID号。</p><p>全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p><p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p><p>你的任务是通过编程，找出断号的ID和重号的ID。</p><p>假设断号不可能发生在最大和最小号。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示后面共有 N 行数据。</p><p>接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>要求程序输出1行，含两个整数 m,n，用空格分隔。</p><p>其中，m表示断号ID，n表示重号ID。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤100</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 6 8 11 9</span><br><span class="line">10 12 9</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sstream库处理string</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);<span class="comment">//读取第一行换行符;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">getline</span>(cin, line);<span class="comment">//读取一行，处理每一行;</span></span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ssin &gt;&gt; a[n]) n++;</span><br><span class="line">    &#125;<span class="comment">//读取数据;</span></span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);<span class="comment">//排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res1, res2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == a[i - <span class="number">1</span>]) res2 = a[i];<span class="comment">//重复;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt;= a[i - <span class="number">1</span>] + <span class="number">2</span>) res1 = a[i] - <span class="number">1</span>;<span class="comment">//前一个数断号</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res2;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分-前缀和-双指针"><a href="#二分-前缀和-双指针" class="headerlink" title="二分 前缀和 双指针"></a>二分 前缀和 双指针</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定三个整数数组</p><p>A&#x3D;[A1,A2,…AN]<br>B&#x3D;[B1,B2,…BN]<br>C&#x3D;[C1,C2,…CN]</p><p>请你统计有多少个三元组 (i,j,k)(i,j,k) 满足：</p><ol><li>1≤i,j,k≤N</li><li>Ai&lt;Bj&lt;Ck</li></ol><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N。</p><p>第二行包含 N个整数 A1,A2,…A。</p><p>第三行包含 N 个整数 B1,B2,…BN。</p><p>第四行包含 N 个整数 C1,C2,…CN。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数表示答案。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤105<br>0≤Ai,Bi,Ci≤10</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> sa[N], sc[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), a[i]++;<span class="comment">//加一防止越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]), b[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]), c[i]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cnt[a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) s[i] = s[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sa[i] = s[b[i] - <span class="number">1</span>];<span class="comment">//减一为之前多加的；</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);<span class="comment">//重置为0；</span></span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cnt[c[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) s[i] = s[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sc[i] = s[N - <span class="number">1</span>] - s[b[i]];<span class="comment">//减一为之前多加的；计算大于b[i]个数</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += (LL)sa[i] * sc[i];</span><br><span class="line">    cout &lt;&lt; res ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目-问题转换"><a href="#题目-问题转换" class="headerlink" title="题目-问题转换"></a>题目-问题转换</h2><p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p><p>在 1∼N 的某个排列中有多少个连号区间呢？</p><p>这里所说的连号区间的定义是：</p><p>如果区间 [L,R][L,R] 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+1的“连续”数列，则称这个区间连号区间。</p><p>当 N 很小的时候，小明可以很快地算出答案，但是当 N 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个正整数 N，表示排列的规模。</p><p>第二行是 N个不同的数字 Pi，表示这 N 个数字的某一排列。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示不同连号区间的数目。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤10000,<br>1≤Pi≤N,</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用例中，有 7 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> INF = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> Max = -INF, Min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, a[j]);</span><br><span class="line">            Min = <span class="built_in">min</span>(Min, a[j]);</span><br><span class="line">            <span class="keyword">if</span>(Max - Min == j - i) res++; <span class="comment">//把上升区间转换为最大值最小值的差，节省time复杂度</span></span><br><span class="line">            <span class="comment">//因为是0 - n的数，不重复；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日期问题 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归枚举指数，排列，组合类型</title>
      <link href="/2025/02/25/%E9%80%92%E5%BD%92/"/>
      <url>/2025/02/25/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>该文本介绍了三个编程题目，均涉及从 1 到 n 的整数中选择和排列数字。第一题要求输出所有可能的选择方案，选择任意多个数字，并确保每行数字升序排列，相邻数字用 1 个空格隔开，包括一个空行表示不选择任何数字的情况。第二题要求将 1 到 n 的整数随机打乱顺序，输出所有可能的排列方案，按字典序排序，每行最多 1 个数字。第三题要求从 1 到 n 的整数中选出 m 个数字，输出所有可能的组合，要求升序排列并按字典序排序，同样每行最多输出 1 个数字。此外，文本还提出了思考题，询问如何使用非递归方法解决这些问题。</p><!-- inject --><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>从 1∼n这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤15</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> n,state[N];<span class="comment">//0跳过，1选，2不选；</span></span><br><span class="line"><span class="comment">//递归实现指数类型枚举，类似集合子集，</span></span><br><span class="line"><span class="comment">//u为第几个位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        state[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">        state[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    state[u] = <span class="number">0</span>;<span class="comment">//恢复现场;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 n。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 1 个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,u;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//当前位置状态</span></span><br><span class="line"><span class="type">bool</span> used[N];<span class="comment">//1选，0不选</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,st[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123; <span class="comment">//没有用过;</span></span><br><span class="line">            st[u] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;<span class="comment">//恢复现场;</span></span><br><span class="line">            st[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>从 1∼n这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数 n,m，在同一行用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 1 个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 <code>1 3 5 7</code> 排在 <code>1 3 6 8</code> 前面）。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>n&gt;0 ,<br>0≤m≤n,<br>n+(n−m)≤25</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 2 4 </span><br><span class="line">1 2 5 </span><br><span class="line">1 3 4 </span><br><span class="line">1 3 5 </span><br><span class="line">1 4 5 </span><br><span class="line">2 3 4 </span><br><span class="line">2 3 5 </span><br><span class="line">2 4 5 </span><br><span class="line">3 4 5 </span><br></pre></td></tr></table></figure><p><strong>思考题</strong>：如果要求使用非递归方法，该怎么做呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//首先有一个way[N]数组，记录路径，u代表当前第几个位置，start代表能开始的最小数</span></span><br><span class="line"><span class="comment">//全局变量way，不需要传递;</span></span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> way[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u ,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剪枝,能选的个数 &lt; 当前位置数，则不满足;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (u<span class="number">-1</span> + n-(start<span class="number">-1</span>) &lt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == m<span class="number">+1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,way[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//换行符</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从当前数字开始枚举当前位置</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">       way[u] = i;</span><br><span class="line">       <span class="built_in">dfs</span>(u + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">       way[u] = <span class="number">0</span>; <span class="comment">//恢复现场；</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP问题2</title>
      <link href="/2025/02/23/DP%E9%97%AE%E9%A2%982/"/>
      <url>/2025/02/23/DP%E9%97%AE%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>题目一涉及计算长度为n且和为s的整数数列的可能方案数，这些数列的后一项总是比前一项增加a或减少b。目标是输出方案数模100000007的结果。题目二则要求在一个n×m的矩阵中统计小明从左上角到右下角的不同路径方案，条件是他必须恰好获取k件宝贝，而每格的宝贝价值需超过他手中的任何宝贝。最终结果也需对1000000007取模。这两个问题都涉及动态规划的应用与分析。</p><!-- inject --><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>观察这个数列：</p><p>1 3 0 2 -1 1 -2 …</p><p>这个数列中后一项总是比前一项增加2或者减少3，<strong>且每一项都为整数</strong>。</p><p>栋栋对这种数列很好奇，他想知道长度为 nn 和为 ss 而且后一项总是比前一项增加 aa 或者减少 bb 的整数数列可能有多少种呢？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含四个整数 n,s,a,bn,s,a,b，含义如前面所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示满足条件的方案数。</p><p>由于这个数很大，请输出方案数除以 100000007100000007 的余数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤10001≤n≤1000,</span><br><span class="line">−109≤s≤109−109≤s≤109,</span><br><span class="line">1≤a,b≤106</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><img src="https://www.chengcc.cn/images/all_dp/dp2.png" style="zoom:80%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f[i][j]表示前i项的总和s 模n的余数为j的所有组合的集合</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, MOD = <span class="number">100000007</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//取正数模</span></span><br><span class="line">    <span class="keyword">return</span> (a % b + b) % b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;<span class="comment">//j的取值为模n的取值，即 0 -&gt; n - 1；</span></span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][<span class="built_in">get_mod</span>(j - a * (n - i), n)] + f[i - <span class="number">1</span>][<span class="built_in">get_mod</span>(j + b * (n - i), n)])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n - <span class="number">1</span>][<span class="built_in">get_mod</span>(s, n)] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>X 国王有一个地宫宝库，是 n×m个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</p><p>地宫的入口在左上角，出口在右下角。</p><p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p><p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p><p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行 33 个整数，n,m,k，含义见题目描述。</p><p>接下来 n 行，每行有 m 个整数 CiCi 用来描述宝库矩阵每个格子的宝贝价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示正好取 k 个宝贝的行动方案数。</p><p>该数字可能很大，输出它对 * 1000000007 * 取模的结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤501≤n,m≤50,</span><br><span class="line">1≤k≤121≤k≤12,</span><br><span class="line">0≤Ci≤12</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">13</span>][<span class="number">14</span>];</span><br><span class="line"><span class="comment">//f[i][j][k][c]表示从开始走到(i, j)取宝贝，当前路径价格为c的路径数;</span></span><br><span class="line"><span class="comment">//如果到(i, j)刚好取得宝贝数为k,则记录;</span></span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> m, k, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">            w[i][j]++;<span class="comment">//有n*m个格子的宝贝价格;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;<span class="comment">//第一个</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//不取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//第一个已经枚举过;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt;= k; u++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt;= <span class="number">13</span>; v++)&#123;</span><br><span class="line">                    <span class="type">int</span> &amp;val = f[i][j][u][v];</span><br><span class="line">                    val = (val + f[i - <span class="number">1</span>][j][u][v]) % MOD;<span class="comment">// 从上方来且不取当前</span></span><br><span class="line">                    val = (val + f[i][j - <span class="number">1</span>][u][v]) % MOD;<span class="comment">// 从左边来方来且不取当前</span></span><br><span class="line">                    <span class="keyword">if</span>(u &gt; <span class="number">0</span> &amp;&amp; v == w[i][j])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; v; c++)&#123;</span><br><span class="line">                            val = (val + f[i - <span class="number">1</span>][j][u - <span class="number">1</span>][c]) % MOD;</span><br><span class="line">                            <span class="comment">//递增序列长度,小于w[i][j]的前c个;</span></span><br><span class="line">                            val = (val + f[i][j - <span class="number">1</span>][u - <span class="number">1</span>][c]) % MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; i++) res = (res + f[n][m][k][i])%MOD;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><ul><li>闫氏dp分析法：</li></ul><img src="https://www.chengcc.cn/images/all_dp/dp3.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP问题</title>
      <link href="/2024/10/19/DP%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/19/DP%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>本文讨论了动态规划（DP）中最基本的背包问题，主要包括01背包、完全背包、多重背包和二维费用背包的特点及求解方法。首先，01背包问题需要在有限的容量内选择物品以最大化价值，通过定义状态f[i][v]来表示前i件物品在容量为v的情况下的最大价值，并进行空间优化至一维数组。完全背包则允许每种物品取无限次，涉及到正序遍历的处理方式。多重背包则通过二进制拆分将其转化为01背包问题，以便于求解。最后，二维费用背包问题结合两种代价，通过状态f[i][v][u]来计算在给定体积和重量限制下的最大价值。这些背包问题的核心在于巧妙的构造子问题和状态转移方程。</p><!-- inject --><h2 id="1-最典型，最基本的dp问题"><a href="#1-最典型，最基本的dp问题" class="headerlink" title="1.最典型，最基本的dp问题"></a>1.最典型，最基本的dp问题</h2><h2 id="2-背包的每个容量就是“状态”"><a href="#2-背包的每个容量就是“状态”" class="headerlink" title="2.背包的每个容量就是“状态”"></a>2.背包的每个容量就是“状态”</h2><ul><li>01背包(最基础的背包问题):</li><li>有N件物品和一个容量为V的背包。第I件物品的费用是c[i]，价值是w[i]。</li><li>求解将哪些物品装入背包可使价值总和最大。</li><li>问题特点:每种物品仅有一件，可以选择放或不放;</li><li>思考:在每个物品都有可能被选中的前提下，如何构造“子问题”?</li><li>无序变有序的方法:依次考虑前1、前2、前3…前i个物品;</li><li><strong>状态定义:<strong>f[i][v]表示</strong>前i件物品</strong>放入一个容量为v的背包可以获得的最大价值。</li></ul><h2 id="3-0-1背包问题优化"><a href="#3-0-1背包问题优化" class="headerlink" title="3.0-1背包问题优化"></a>3.0-1背包问题优化</h2><ul><li>1背包问题伪代码如下:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n            <span class="comment">//所有物品;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j = V  to v[i]     <span class="comment">//思考:为何没必要循环到0?</span></span><br><span class="line"></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j - v[i]] + w[i],dp[j]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>- </p><ul><li><p>空间成功优化到一维V。因为j小于v[i]时已经不满足条件。</p></li><li><p>整个代码如下</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>], w[<span class="number">1000</span>],c[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> num,n, V, i j</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"><span class="keyword">while</span>(num--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;V) <span class="comment">//输入物品n个，背包容量为V</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]); <span class="comment">//输入物品价值</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]); <span class="comment">//输入物品体积</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));<span class="comment">//dp数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++ )</span><br><span class="line"><span class="keyword">for</span>(j=V; j&gt;=c[i]; j--)</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-c[i]] + w[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的代码是按逆序遍历数组，可以避免同一物品被拿多次。</p><h2 id="4-完全背包"><a href="#4-完全背包" class="headerlink" title="4.完全背包"></a>4.完全背包</h2><ul><li><p>完全背包特点:一种物品可以取无数个</p></li><li><p>可否转化成01背包问题?</p></li><li><p>朴素的转化方式是?</p></li><li><p>回忆01背包为何要对容量按照逆序循环?</p></li><li><p>和01背包类似,不过就是正着写（因为正着写可能会有同个物品重复拿取的情况，而完全背包符合这种特点）</p></li><li><p>深度思考:这类能不能达到的问题应该怎么实现?</p></li></ul><h2 id="5-多重背包"><a href="#5-多重背包" class="headerlink" title="5.多重背包"></a>5.多重背包</h2><ul><li><p>多重背包特点:<br>一种物品有C个，既不是固定的1，也不是无数个，是可以被分的</p></li><li><p>优化的方法:</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h4><p>将每类物品的数量 <code>C</code> 拆分成若干组，每组包含 <code>1, 2, 4, ..., 2^&#123;k-1&#125;, C - (2^k - 1)</code> 个物品，通过这些组的组合可表示 <code>1~C</code> 之间的任意数量。这样将多重背包转化为 <code>log(C)</code> 个物品的01背包问题，时间复杂度从 <strong>O(N*V* C)</strong> 降至 <strong>O(N*V* logC)</strong> </p></li><li><p>运用二进制，进行物品拆分,转化成01背包<br>比如:13余相同的物品可分成4组(1,2,4,6)<br>用这4组可以组成任意一个1~13之间的数!<br>原理:一个数总可以用2^k表示</p></li><li><p>然后进行01背包</p></li><li><p>优化部分的参考代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 拆分后的物品总数</span></span><br><span class="line">  <span class="type">int</span> x = C;    <span class="comment">// *当前剩余数量*</span></span><br><span class="line">  <span class="type">int</span> t = <span class="number">1</span>;    <span class="comment">// 当前二进制基数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (t &lt;= x) &#123;</span><br><span class="line">      v[cnt] = a * t;   <span class="comment">// 体积为原体积乘以数量t</span></span><br><span class="line">      c[cnt] = b * t;   <span class="comment">// 价值为原价值乘以数量t</span></span><br><span class="line">      cnt++;</span><br><span class="line">      x -= t;           <span class="comment">// 剩余数量减少t</span></span><br><span class="line">      t &lt;&lt;= <span class="number">1</span>;          <span class="comment">// 基数翻倍（等效于 t *= 2）</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理剩余不足t的部分</span></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      v[cnt] = a * x;</span><br><span class="line">      c[cnt] = b * x;</span><br><span class="line">      cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">- ***<span class="number">01</span>背包部分***</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="type">int</span> dp[N]; <span class="comment">// dp[j] 表示容量j时的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化dp数组</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有拆分后的物品</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">    <span class="comment">// 逆序遍历容量（01背包特性）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= v[i]; j--) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-二维费用背包"><a href="#6-二维费用背包" class="headerlink" title="6.二维费用背包"></a>6.二维费用背包</h2><p>二维费用背包问题<br>对于每件物品，具有两种不同的费用，选择这件物品必须同时付<br>出这两种代价;对于每种代价都有一个可付出的最大值(比如，<br>背包容量、最大承重)，求怎样选择物品可以得到最大的价值。<br>设第i件物品所需的两种代价分别为a[i]和b[i]，两种代价可付<br>出的最大值(比如体积和重量)分别为V和U，物品的价值为w[i]。<br><strong>对应算法:费用加了一维，只需状态也加一维即可!</strong><br>设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的<br>最大价值，状态转移方程则为:</p><ul><li>f[i][v][u]&#x3D;max( f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i])</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求和</title>
      <link href="/2024/09/22/study_list/"/>
      <url>/2024/09/22/study_list/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表实践-多项式-一"><a href="#线性表实践-多项式-一" class="headerlink" title="线性表实践-多项式(一)"></a>线性表实践-多项式(一)</h2><p>多项式的实现有两种方式：</p><p>一种为顺序存储结构的顺序表，另一种为线性表的链式存储的链表，本文采用后者。</p><h3 id="1。链表创建以及初始化"><a href="#1。链表创建以及初始化" class="headerlink" title="1。链表创建以及初始化"></a>1。链表创建以及初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Polynode,*Polylist;</span><br><span class="line">Polylist <span class="title function_">PolyCreat</span><span class="params">()</span>&#123;</span><br><span class="line">    Polynode *head,*rear,*s;</span><br><span class="line">    <span class="type">int</span> c,e;</span><br><span class="line">    head = (Polynode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Polynode));</span><br><span class="line">    rear = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c,&amp;e);</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">        s = (Polynode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Polynode));</span><br><span class="line">        s-&gt;coef = c;</span><br><span class="line">        s-&gt;<span class="built_in">exp</span> = e;</span><br><span class="line">        rear-&gt;next = s;</span><br><span class="line">        rear =s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c,&amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Polynode *head)</span>&#123;</span><br><span class="line">    Polynode *current = head;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d*x^%d &quot;</span>, current-&gt;coef, current-&gt;<span class="built_in">exp</span>);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Polylist la = <span class="literal">NULL</span>;</span><br><span class="line">    la = PolyCreat();</span><br><span class="line">    print(la);</span><br><span class="line">    <span class="comment">//释放链表内存；</span></span><br><span class="line">    Polynode *temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (la!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = la;</span><br><span class="line">        la = la-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客教程</title>
      <link href="/2024/08/18/second/"/>
      <url>/2024/08/18/second/</url>
      
        <content type="html"><![CDATA[<p><i class="fa-solid fa-truck-fast"></i>  <strong>以下摘要由GPT-4o生成</strong>:<br>本文提供了一个简洁的Hexo博客搭建教程，主要步骤包括准备工具、下载并测试所需软件（Node.js、npm、Git），创建GitHub仓库以存储静态页面，并生成SSH密钥进行安全连接。之后，通过命令行生成本地博客内容并运行本地服务器，再进行配置以将其上线。最后，安装自动部署工具并完成内容上传至GitHub，最终用户可通过设置的域名访问自己的博客。</p><!-- inject --><h2 id="博客搭建推荐学习视频-本人Studying-site"><a href="#博客搭建推荐学习视频-本人Studying-site" class="headerlink" title="博客搭建推荐学习视频(本人Studying site.)"></a><a href="https://www.bilibili.com/video/BV1Ju4m1c7WR/">博客搭建推荐学习视频</a>(本人Studying site.)</h2><p><strong>开始文档教程，本文比较精简，没有废话。</strong></p><h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a><strong>准备工具</strong></h1><p>首先我们需要到对应网站下载需要的工具</p><p>如同安装普通软件一样，跟着操作走就行</p><p>(详细安装git<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">教程</a>)</p><p><strong>接下来我们测试下是否都下载成功</strong></p><p>管理员模式运行命令符,依次输入</p><p><code>1 node -v</code></p><p><code>2 npm -v</code></p><p><code>3 git -v</code></p><p><strong>下载hexo</strong></p><p><code>npm install hexo-cli -g</code></p><h1 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h1><p>成功下载好工具之后，我们开始搭建GitHub存储静态页面的仓库</p><p>首先注册&#x2F;登入<a href="https://github.com/">github</a></p><p>点击Create a new repository进入新建仓库页面</p><p>仓库名输入：</p><p><code>用户名.github.io</code></p><p>（格式是固定的前面为github用户名）</p><p>勾选 Public</p><p>勾选 Add a README file</p><p>拉到下面点击create创建</p><h1 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h1><p>进入任意文件夹，右键空白处然后点Git bash here,输入</p><p><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p><p>然后敲4次Enter⌨️</p><p>然后进入C:\Users\用户名，在里面进入.ssh文件</p><p>用记事本打开里面的id_rsa.pub,全选复制里面的代码</p><p>然后打开github</p><p>进入用户设置，找到SSH keys</p><p>新建SSH keys，名称随意，在下面粘贴代码，</p><p>然后创建</p><p>测试是否成功</p><p>在git bash中输入</p><p><code>ssh -T git@github.com</code></p><p>回车，输入yes</p><h1 id="本地生成博客内容"><a href="#本地生成博客内容" class="headerlink" title="本地生成博客内容"></a>本地生成博客内容</h1><p>在喜欢位置新建文件Blog，然后进入文件夹</p><p>右键空白处然后点Git bash here，输入</p><p><code>hexo init</code>（如果command not find）就在前面加上npx</p><p>然后</p><p><code>hexo install</code></p><p>依次输入</p><p><code>hexo g (生成静态文件)</code></p><p><code>hexo s（运行本地hexo服务器）</code></p><p>（如果不成功的话就重复直到成功，因为国内与github连接不稳定）</p><p>现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了</p><p>然后回到命令行，ctrl+c关闭</p><h1 id="上线博客"><a href="#上线博客" class="headerlink" title="上线博客"></a>上线博客</h1><p>进入之前的Blog文件夹，用记事本打开_config.yml</p><p>拉到最下面将deploy后面的全删掉，复制粘贴这段</p><p>  –<code>type: git</code></p><p>  –<code>repository:</code> </p><p>  –<code>branch: main</code></p><p><strong>注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！</strong></p><p>去github之前生成的仓库页面，点code，复制https链接</p><p>将其粘贴到我们记事本中的<code>repository：</code>后面</p><p>然后保存退出</p><p><strong>回到博客文件夹，git bash</strong></p><p>安装自动部署发布工具</p><p><code>npm install hexo-deployer-git --save</code></p><p>然后在Blog文件夹右键打开git bash，依次输入</p><p><code>hexo g（生成）</code><br><code>hexo d（上传）</code></p><p>接下来我们就成功把本地内容上传到github了</p><p>上传成功以后，我们就算搭建好了！上自己的网址看看吧</p><p>网址是我们之前设的仓库名：用户名.github.io</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    
  
  
</search>
